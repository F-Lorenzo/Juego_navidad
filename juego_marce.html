<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Minigolf Web Pro - Edici√≥n Regalo</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600&display=swap');
        
        body {
            font-family: 'Fredoka', sans-serif;
            touch-action: none; /* Previene scroll en m√≥viles al jugar */
            background-color: #1a472a;
            overflow: hidden;
        }

        #game-container {
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.5);
        }

        canvas {
            background-color: #4ade80; /* Color base del c√©sped */
            background-image: 
                radial-gradient(#22c55e 15%, transparent 16%),
                radial-gradient(#22c55e 15%, transparent 16%);
            background-size: 20px 20px;
            background-position: 0 0, 10px 10px;
            cursor: crosshair;
            border-radius: 8px;
        }

        .wood-texture {
            background-color: #78350f;
            background-image: repeating-linear-gradient(45deg, rgba(255,255,255,0.05) 0px, rgba(255,255,255,0.05) 2px, transparent 2px, transparent 4px);
        }

        /* Animaci√≥n para la caja de regalo */
        @keyframes wiggle {
            0%, 100% { transform: rotate(-3deg); }
            50% { transform: rotate(3deg); }
        }
        .wiggle:hover {
            animation: wiggle 0.5s ease-in-out infinite;
        }
    </style>
</head>
<body class="h-screen w-full flex flex-col items-center justify-center text-white">

    <!-- UI Overlay -->
    <div class="w-full max-w-2xl px-4 mb-2 flex justify-between items-center z-10">
        <div class="bg-black/40 backdrop-blur-md rounded-xl p-3 flex gap-4 border border-white/10">
            <div class="text-center">
                <p class="text-xs text-green-300 uppercase tracking-wider font-bold">Nivel</p>
                <p class="text-2xl font-bold" id="level-display">1</p>
            </div>
            <div class="w-px bg-white/20"></div>
            <div class="text-center">
                <p class="text-xs text-yellow-300 uppercase tracking-wider font-bold">Golpes</p>
                <p class="text-2xl font-bold" id="stroke-display">0</p>
            </div>
            <div class="w-px bg-white/20"></div>
            <div class="text-center">
                <p class="text-xs text-blue-300 uppercase tracking-wider font-bold">Total</p>
                <p class="text-2xl font-bold" id="total-score-display">0</p>
            </div>
        </div>

        <button onclick="game.resetLevel()" class="bg-red-500 hover:bg-red-600 text-white rounded-full w-12 h-12 flex items-center justify-center shadow-lg transition-transform active:scale-95" title="Reiniciar Nivel">
            <i class="fas fa-undo"></i>
        </button>
    </div>

    <!-- Game Canvas Container -->
    <div id="game-container" class="relative p-2 bg-[#5d4037] rounded-xl border-4 border-[#3e2723]">
        <canvas id="canvas"></canvas>
        
        <!-- Mensaje de Nivel Completado -->
        <div id="message-overlay" class="absolute inset-0 flex items-center justify-center bg-black/60 backdrop-blur-sm hidden rounded-lg z-20">
            <div class="bg-white text-gray-800 p-6 rounded-2xl shadow-2xl text-center transform scale-100 transition-all max-w-xs w-full mx-4">
                <div class="text-5xl mb-2">‚õ≥</div>
                <h2 class="text-2xl font-bold mb-1 text-green-600" id="msg-title">¬°Hoyo en Uno!</h2>
                <p class="text-gray-500 mb-4" id="msg-subtitle">Buen tiro</p>
                
                <!-- Pista del Regalo -->
                <div class="mb-4 p-3 bg-blue-50 rounded-lg border border-blue-100">
                    <p class="text-sm text-blue-800 font-bold uppercase tracking-wide">Pista del Regalo:</p>
                    <p class="text-lg text-blue-600 font-semibold" id="msg-clue">Aqu√≠ va la pista...</p>
                </div>

                <button onclick="game.nextLevel()" class="w-full py-3 bg-green-500 hover:bg-green-600 text-white rounded-xl font-bold text-lg shadow-lg transition-colors" id="next-level-btn">
                    Siguiente Nivel
                </button>
            </div>
        </div>

        <!-- Caja de Regalo Final -->
        <div id="gift-box-overlay" class="absolute inset-0 flex items-center justify-center bg-black/60 backdrop-blur-sm hidden rounded-lg z-30">
            <div class="bg-white p-6 rounded-2xl shadow-2xl text-center transform scale-100 transition-all max-w-xs w-full mx-4 flex flex-col items-center">
                <h2 class="text-2xl font-bold mb-2 text-green-600">¬°Felicidades!</h2>
                <p class="text-gray-500 mb-4">¬°Has completado todos los niveles!</p>
                <p class="text-lg text-blue-500 font-semibold mb-6" id="gift-instruction">Toca la caja para ver tu regalo</p>
                
                <!-- Caja con signo de interrogaci√≥n -->
                <div id="mystery-box" class="w-40 h-40 bg-gradient-to-br from-yellow-400 to-orange-500 rounded-2xl flex items-center justify-center cursor-pointer shadow-xl hover:scale-105 transition-transform wiggle" onclick="game.revealGift()">
                    <span class="text-7xl text-white font-bold drop-shadow-md">?</span>
                </div>

                <!-- Imagen del regalo (inicialmente oculta) -->
                <div id="gift-reveal" class="hidden flex flex-col items-center w-full">
                    <!-- Imagen actualizada con mejor fallback -->
                    <img 
                        src="image_b48585.jpg" 
                        onerror="this.onerror=null; this.src='https://images.unsplash.com/photo-1591491640784-3232eb18e7c3?q=80&w=800&auto=format&fit=crop'; this.alt='Golf Equipment';"
                        alt="Tel√©metro L√°ser para Golf" 
                        class="w-full h-auto rounded-xl shadow-lg mb-4 border-4 border-green-500 object-cover"
                        style="max-height: 250px;"
                    >
                    <p class="text-xl font-bold text-gray-800">¬°Un Tel√©metro L√°ser!</p>
                    <p class="text-gray-600 text-sm mt-2">Para que no falles ni una yarda.</p>
                </div>
            </div>
        </div>

        <!-- Instrucciones iniciales -->
        <div id="tutorial-overlay" class="absolute inset-0 flex items-center justify-center pointer-events-none">
            <div class="bg-black/50 text-white px-4 py-2 rounded-full backdrop-blur text-sm animate-pulse">
                Arrastra la bola para golpear üñ±Ô∏èüëÜ
            </div>
        </div>
    </div>

    <p class="mt-4 text-white/50 text-sm">Desarrollado con HTML5 Canvas</p>

<script>
/**
 * L√≥gica del Juego de Minigolf
 */

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

// Configuraci√≥n Global
const GAME_WIDTH = 800;
const GAME_HEIGHT = 500;
const FRICTION = 0.975; // Cuanto menor, m√°s r√°pido frena (0-1)
const MAX_POWER = 15; // Velocidad m√°xima
const WALL_BOUNCE = 0.7; // Energ√≠a conservada al rebotar

// Estado del Juego
const state = {
    currentLevel: 0,
    strokes: 0,
    totalScore: 0,
    isAiming: false,
    isMoving: false,
    ball: { x: 0, y: 0, vx: 0, vy: 0, r: 8 },
    hole: { x: 0, y: 0, r: 12 },
    mouse: { x: 0, y: 0, startX: 0, startY: 0 },
    obstacles: [], // Paredes internas
    levelCompleted: false
};

// Definici√≥n de Niveles
const levels = [
    // Nivel 1: Recta simple
    {
        start: { x: 100, y: 250 },
        hole: { x: 700, y: 250 },
        obstacles: [
            { x: 300, y: 100, w: 20, h: 100 },
            { x: 300, y: 300, w: 20, h: 100 }
        ],
        clue: "Pista 1: Es un dispositivo electr√≥nico peque√±o."
    },
    // Nivel 2: La curva
    {
        start: { x: 80, y: 400 },
        hole: { x: 700, y: 100 },
        obstacles: [
            { x: 300, y: 200, w: 20, h: 300 }, // Pared vertical abajo
            { x: 300, y: 0, w: 20, h: 100 },   // Pared vertical arriba
            { x: 500, y: 200, w: 200, h: 20 }  // Pared horizontal
        ],
        clue: "Pista 2: Se utiliza principalmente al aire libre."
    },
    // Nivel 3: El laberinto
    {
        start: { x: 50, y: 50 },
        hole: { x: 750, y: 450 },
        obstacles: [
            { x: 150, y: 0, w: 20, h: 350 },
            { x: 350, y: 150, w: 20, h: 350 },
            { x: 550, y: 0, w: 20, h: 350 },
            { x: 550, y: 420, w: 200, h: 20 }
        ],
        clue: "Pista 3: Tiene una lente √≥ptica."
    },
    // Nivel 4: El t√∫nel t√°ctico (M√°s dif√≠cil)
    {
        start: { x: 50, y: 250 },
        hole: { x: 750, y: 250 },
        obstacles: [
            { x: 180, y: 160, w: 440, h: 20 }, // Techo del t√∫nel
            { x: 180, y: 320, w: 440, h: 20 }, // Suelo del t√∫nel
            { x: 390, y: 210, w: 20, h: 80 }   // Columna central: Bloquea el tiro directo, obliga a rebotar
        ],
        clue: "Pista 4: Te ayuda a elegir el palo exacto sin tener que adivinar."
    },
    // Nivel 5: El desaf√≠o final (Nuevo)
    {
        start: { x: 100, y: 100 },
        hole: { x: 700, y: 400 },
        obstacles: [
            { x: 300, y: 0, w: 20, h: 200 },
            { x: 500, y: 300, w: 20, h: 200 },
            { x: 200, y: 300, w: 200, h: 20 },
            { x: 400, y: 100, w: 200, h: 20 }
        ],
        clue: "¬°√öltima pista! ¬°Es esencial para mejorar tu juego de golf!"
    }
];

class Game {
    constructor() {
        this.resize();
        window.addEventListener('resize', () => this.resize());
        this.loadLevel(0);
        this.setupInput();
        this.loop();
    }

    resize() {
        // Mantener aspect ratio pero escalar
        const container = document.getElementById('game-container');
        const maxWidth = Math.min(window.innerWidth - 32, 800);
        const scale = maxWidth / GAME_WIDTH;
        
        canvas.width = GAME_WIDTH;
        canvas.height = GAME_HEIGHT;
        
        canvas.style.width = `${maxWidth}px`;
        canvas.style.height = `${maxWidth * (GAME_HEIGHT / GAME_WIDTH)}px`;
        
        this.scale = scale;
    }

    loadLevel(index) {
        if (index >= levels.length) {
            // Juego terminado, reiniciar
            state.totalScore = 0;
            state.currentLevel = 0;
            index = 0;
        }

        const levelData = levels[index];
        state.ball.x = levelData.start.x;
        state.ball.y = levelData.start.y;
        state.ball.vx = 0;
        state.ball.vy = 0;
        state.hole = { ...levelData.hole, r: 14 }; // Un poco m√°s grande para ser generoso
        state.obstacles = levelData.obstacles;
        state.strokes = 0;
        state.isMoving = false;
        state.levelCompleted = false;

        this.updateUI();
        document.getElementById('message-overlay').classList.add('hidden');
        
        // Resetear el estado de la caja de regalo para el pr√≥ximo juego
        document.getElementById('gift-box-overlay').classList.add('hidden');
        document.getElementById('mystery-box').classList.remove('hidden');
        document.getElementById('gift-reveal').classList.add('hidden');
        document.getElementById('gift-instruction').classList.remove('hidden');

        
        // Ocultar tutorial despu√©s del primer golpe
        if(index > 0) {
            document.getElementById('tutorial-overlay').style.display = 'none';
        } else {
             document.getElementById('tutorial-overlay').style.display = 'flex';
        }
    }

    updateUI() {
        document.getElementById('level-display').textContent = state.currentLevel + 1;
        document.getElementById('stroke-display').textContent = state.strokes;
        document.getElementById('total-score-display').textContent = state.totalScore;
    }

    getMousePos(evt) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        
        let clientX, clientY;
        
        if (evt.touches && evt.touches.length > 0) {
            clientX = evt.touches[0].clientX;
            clientY = evt.touches[0].clientY;
        } else {
            clientX = evt.clientX;
            clientY = evt.clientY;
        }

        return {
            x: (clientX - rect.left) * scaleX,
            y: (clientY - rect.top) * scaleY
        };
    }

    setupInput() {
        const startAim = (e) => {
            if (state.isMoving || state.levelCompleted) return;
            const pos = this.getMousePos(e);
            
            // Check si clickea cerca de la bola
            const dx = pos.x - state.ball.x;
            const dy = pos.y - state.ball.y;
            if (dx*dx + dy*dy < 1600) { // 40px radius click area
                state.isAiming = true;
                state.mouse.startX = pos.x;
                state.mouse.startY = pos.y;
                state.mouse.x = pos.x;
                state.mouse.y = pos.y;
                document.getElementById('tutorial-overlay').style.display = 'none';
            }
        };

        const moveAim = (e) => {
            if (!state.isAiming) return;
            e.preventDefault(); // Prevenir scroll en touch
            const pos = this.getMousePos(e);
            state.mouse.x = pos.x;
            state.mouse.y = pos.y;
        };

        const endAim = () => {
            if (!state.isAiming) return;
            
            // Calcular vector de fuerza (invertido: arrastrar atr√°s para disparar adelante)
            let dx = state.ball.x - state.mouse.x; // Vector desde mouse a bola
            let dy = state.ball.y - state.mouse.y;
            
            // Calcular magnitud
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            if (dist > 10) { // M√≠nimo arrastre requerido
                state.strokes++;
                state.totalScore++;
                this.updateUI();
                
                // Normalizar y aplicar potencia limitada
                const power = Math.min(dist * 0.15, MAX_POWER);
                const angle = Math.atan2(dy, dx);
                
                state.ball.vx = Math.cos(angle) * power;
                state.ball.vy = Math.sin(angle) * power;
                state.isMoving = true;
            }
            
            state.isAiming = false;
        };

        canvas.addEventListener('mousedown', startAim);
        canvas.addEventListener('mousemove', moveAim);
        window.addEventListener('mouseup', endAim);
        
        canvas.addEventListener('touchstart', startAim, {passive: false});
        canvas.addEventListener('touchmove', moveAim, {passive: false});
        window.addEventListener('touchend', endAim);
    }

    checkCollisions() {
        const ball = state.ball;

        // 1. Bordes del Canvas
        if (ball.x - ball.r < 0) {
            ball.x = ball.r;
            ball.vx = -ball.vx * WALL_BOUNCE;
        } else if (ball.x + ball.r > GAME_WIDTH) {
            ball.x = GAME_WIDTH - ball.r;
            ball.vx = -ball.vx * WALL_BOUNCE;
        }
        if (ball.y - ball.r < 0) {
            ball.y = ball.r;
            ball.vy = -ball.vy * WALL_BOUNCE;
        } else if (ball.y + ball.r > GAME_HEIGHT) {
            ball.y = GAME_HEIGHT - ball.r;
            ball.vy = -ball.vy * WALL_BOUNCE;
        }

        // 2. Obst√°culos (Rect√°ngulos)
        state.obstacles.forEach(obs => {
            // Encontrar el punto m√°s cercano en el rect√°ngulo al centro del c√≠rculo
            let closestX = Math.max(obs.x, Math.min(ball.x, obs.x + obs.w));
            let closestY = Math.max(obs.y, Math.min(ball.y, obs.y + obs.h));

            let distanceX = ball.x - closestX;
            let distanceY = ball.y - closestY;
            let distanceSquared = (distanceX * distanceX) + (distanceY * distanceY);

            // Colisi√≥n detectada
            if (distanceSquared < (ball.r * ball.r)) {
                // Resolver colisi√≥n empujando la bola fuera y rebotando
                
                // Determinar lado de colisi√≥n
                const overlapX = (ball.r) - Math.abs(distanceX);
                const overlapY = (ball.r) - Math.abs(distanceY);

                // Si estamos exactamente dentro (raro pero posible), o en esquinas
                // L√≥gica simplificada: Rebotar en el eje con menor penetraci√≥n profunda o basado en posici√≥n relativa
                
                // Truco para AABB vs Circle respuesta simple:
                // Si la distancia en X al centro del rect es mayor que en Y (proporcionalmente al tama√±o), golpeamos lado, sino arriba/abajo
                
                // M√©todo robusto: comparar la penetraci√≥n
                // Como ya tenemos closestX/Y, podemos ver de d√≥nde venimos
                
                // Detectar si golpeamos costados o arriba/abajo
                // Si el closest point es una esquina, es m√°s complejo, pero para minigolf simple:
                
                // Verificar si estamos "m√°s verticales" o "m√°s horizontales" respecto al centro del obst√°culo
                const centerX = obs.x + obs.w/2;
                const centerY = obs.y + obs.h/2;
                const dx = ball.x - centerX;
                const dy = ball.y - centerY;
                
                // Normalizar por ancho/alto para ver el √°ngulo de incidencia relativo a la forma
                const combinedW = obs.w/2 + ball.r;
                const combinedH = obs.h/2 + ball.r;
                
                // Detecci√≥n simple de lado
                const penX = (combinedW - Math.abs(dx));
                const penY = (combinedH - Math.abs(dy));

                if (penX < penY) {
                    // Colisi√≥n Horizontal (Lados)
                    if (dx > 0) ball.x += penX; // Empujar derecha
                    else ball.x -= penX;        // Empujar izquierda
                    ball.vx = -ball.vx * WALL_BOUNCE;
                } else {
                    // Colisi√≥n Vertical (Arriba/Abajo)
                    if (dy > 0) ball.y += penY; // Empujar abajo
                    else ball.y -= penY;        // Empujar arriba
                    ball.vy = -ball.vy * WALL_BOUNCE;
                }
            }
        });

        // 3. Hoyo
        const dx = ball.x - state.hole.x;
        const dy = ball.y - state.hole.y;
        const dist = Math.sqrt(dx*dx + dy*dy);

        // Si la bola est√° cerca del hoyo y va lo suficientemente lento
        if (dist < state.hole.r && (Math.abs(ball.vx) + Math.abs(ball.vy)) < 6) {
            this.handleWin();
        }
    }

    update() {
        if (!state.isMoving) return;

        // F√≠sica
        state.ball.x += state.ball.vx;
        state.ball.y += state.ball.vy;
        
        // Fricci√≥n
        state.ball.vx *= FRICTION;
        state.ball.vy *= FRICTION;

        // Detener si es muy lento
        if (Math.abs(state.ball.vx) < 0.05 && Math.abs(state.ball.vy) < 0.05) {
            state.ball.vx = 0;
            state.ball.vy = 0;
            state.isMoving = false;
        }

        this.checkCollisions();
    }

    draw() {
        // Limpiar
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Dibujar Hoyo
        ctx.beginPath();
        ctx.arc(state.hole.x, state.hole.y, state.hole.r, 0, Math.PI * 2);
        ctx.fillStyle = '#1a1a1a';
        ctx.fill();
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Dibujar Obst√°culos
        ctx.fillStyle = '#a16207'; // Madera
        ctx.strokeStyle = '#713f12';
        
        state.obstacles.forEach(obs => {
            // Sombra
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.fillRect(obs.x + 4, obs.y + 4, obs.w, obs.h);
            
            // Madera
            ctx.fillStyle = '#8D6E63';
            ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
            // Borde
            ctx.lineWidth = 2;
            ctx.strokeRect(obs.x, obs.y, obs.w, obs.h);
            
            // Detalle madera simple
            ctx.beginPath();
            ctx.moveTo(obs.x + 5, obs.y + 5);
            ctx.lineTo(obs.x + obs.w - 5, obs.y + obs.h - 5);
            ctx.strokeStyle = 'rgba(0,0,0,0.1)';
            ctx.stroke();
        });

        // Dibujar l√≠nea de punter√≠a
        if (state.isAiming) {
            ctx.beginPath();
            ctx.moveTo(state.ball.x, state.ball.y);
            // La l√≠nea va en direcci√≥n opuesta al mouse
            const dx = state.ball.x - state.mouse.x;
            const dy = state.ball.y - state.mouse.y;
            
            // Limitar longitud visual de la l√≠nea
            const angle = Math.atan2(dy, dx);
            const dist = Math.sqrt(dx*dx + dy*dy);
            const power = Math.min(dist * 0.15, MAX_POWER); // Misma l√≥gica que f√≠sica
            const visLen = power * 10; // Escalar para visualizaci√≥n
            
            const endX = state.ball.x + Math.cos(angle) * visLen;
            const endY = state.ball.y + Math.sin(angle) * visLen;

            // Gradiente de color seg√∫n potencia
            const grad = ctx.createLinearGradient(state.ball.x, state.ball.y, endX, endY);
            grad.addColorStop(0, 'white');
            grad.addColorStop(1, power > 10 ? 'red' : 'yellow');

            ctx.lineTo(endX, endY);
            ctx.strokeStyle = grad;
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        // Dibujar Bola
        ctx.beginPath();
        ctx.arc(state.ball.x, state.ball.y, state.ball.r, 0, Math.PI * 2);
        
        // Sombra bola
        if(state.isMoving) {
             ctx.fillStyle = 'rgba(0,0,0,0.2)';
             ctx.fill(); // Sombra simple, mejorar despu√©s desplazando
        }
        
        ctx.fillStyle = 'white';
        ctx.fill();
        ctx.strokeStyle = '#ccc';
        ctx.lineWidth = 1;
        ctx.stroke();
        
        // Brillo bola
        ctx.beginPath();
        ctx.arc(state.ball.x - 2, state.ball.y - 2, 2, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255,255,255,0.8)';
        ctx.fill();
    }

    handleWin() {
        if (state.levelCompleted) return;
        state.levelCompleted = true;
        state.isMoving = false;
        
        // Snap al centro
        state.ball.x = state.hole.x;
        state.ball.y = state.hole.y;

        // Si es el √∫ltimo nivel, mostrar la caja de regalo
        if (state.currentLevel === levels.length - 1) {
            document.getElementById('gift-box-overlay').classList.remove('hidden');
            return;
        }
        
        // Mostrar UI normal de nivel completado
        const overlay = document.getElementById('message-overlay');
        const title = document.getElementById('msg-title');
        const sub = document.getElementById('msg-subtitle');
        const clue = document.getElementById('msg-clue');
        
        overlay.classList.remove('hidden');

        // Mostrar la pista del nivel actual
        clue.textContent = levels[state.currentLevel].clue;
        
        if (state.strokes === 1) {
            title.textContent = "¬°Hoyo en Uno!";
            title.className = "text-2xl font-bold mb-1 text-purple-600 animate-bounce";
            sub.textContent = "¬°Incre√≠ble!";
        } else if (state.strokes <= 3) {
            title.textContent = "¬°Nivel Completado!";
            title.className = "text-2xl font-bold mb-1 text-green-600";
            sub.textContent = "¬°Bien hecho!";
        } else {
            title.textContent = "¬°Nivel Completado!";
            title.className = "text-2xl font-bold mb-1 text-blue-600";
            sub.textContent = "La pr√°ctica hace al maestro.";
        }
    }

    nextLevel() {
        state.currentLevel++;
        this.loadLevel(state.currentLevel);
    }

    // Nueva funci√≥n para revelar el regalo
    revealGift() {
        document.getElementById('mystery-box').classList.add('hidden');
        document.getElementById('gift-instruction').classList.add('hidden');
        document.getElementById('gift-reveal').classList.remove('hidden');
    }

    resetLevel() {
        // Penalizaci√≥n por reset? Nah, es minigolf relajante
        this.loadLevel(state.currentLevel);
    }

    loop() {
        this.update();
        this.draw();
        requestAnimationFrame(() => this.loop());
    }
}

// Iniciar Juego
const game = new Game();

</script>
</body>
</html>